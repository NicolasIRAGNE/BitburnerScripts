<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>overseer.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <li class="nav-link nav-home-link"><a href="index.html">Home</a></li><li class="nav-heading">Classes</li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="Batch.html">Batch</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Batch.html#add">add</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="ExecutionPolicy.html">ExecutionPolicy</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="Host.html">Host</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Host.html#exec">exec</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Host.html#killall">killall</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Host.html#repr">repr</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="Node.html">Node</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Node.html#fill">fill</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Node.html#matchesPolicy">matchesPolicy</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Node.html#run">run</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Node.html#satisfaction">satisfaction</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="Task.html">Task</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="WorkloadManager.html">WorkloadManager</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="WorkloadManager.html#add_node">add_node</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="WorkloadManager.html#assign">assign</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="WorkloadManager.html#fill">fill</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="WorkloadManager.html#get_available_ram">get_available_ram</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="WorkloadManager.html#get_total_ram">get_total_ram</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="WorkloadManager.html#map">map</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="WorkloadManager.html#summary">summary</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="WorkloadManager.html#update">update</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="WorkloadManager.html#update_network">update_network</a></span></li><li class="nav-heading"><a href="global.html">Globals</a></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#augmentScore">augmentScore</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#createHost">createHost</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#createNode">createNode</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#createWorkloadManager">createWorkloadManager</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#expect_eq">expect_eq</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#expect_false">expect_false</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#expect_float_eq">expect_float_eq</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#expect_float_neq">expect_float_neq</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#expect_gt">expect_gt</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#expect_gte">expect_gte</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#expect_instanceof">expect_instanceof</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#expect_lt">expect_lt</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#expect_lte">expect_lte</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#expect_neq">expect_neq</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#expect_nothrow">expect_nothrow</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#expect_null">expect_null</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#expect_throw">expect_throw</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#expect_true">expect_true</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#generate_batch">generate_batch</a></span></li><li class="nav-item"><span class="nav-item-type type-member">M</span><span class="nav-item-name"><a href="global.html#HostType">HostType</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#init">init</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#killall">killall</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#print_status">print_status</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#printReport">printReport</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#prof">prof</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#recurse_scan">recurse_scan</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#recurse_scan_legacy">recurse_scan_legacy</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#scrap_host">scrap_host</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#try_nuke">try_nuke</a></span></li>
</nav>

<div id="main">
    
    <h1 class="page-title">overseer.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * The overseer program manages an entire network and dictates the actions of all the other programs.
 * For each host in the network, the overseer will install and run appropriate programs to target a list of targets.
 */

import * as lib from "./lib/lib.js";
import * as wm from "./lib/workload_manager.js";
import * as t from "./lib/testing.js";

async function backdoor(ns, hostname)
{
    if (ns.getServer(hostname).requiredHackingSkill &lt;= await ns.getHackingLevel())
    {
        await ns.singularity.connect(hostname);
        await ns.singularity.installBackdoor(hostname);
    }
}


/**
 * Generate a batch that will steal hackTarget of a target's money then grow it back to its original money and security
 * This function assumes that the target current security is at its minimum and current money is at its maximum
 * @param {NS} ns 
 * @param {lib.Host} host 
 */
async function generate_batch(ns, host, prep = false)
{
    const hackTarget = 0.5;
    // First, compute the power needed to steal hackTarget of the target's money
    // In some cases, even with a power of 1, we will steal more than hackTarget. In that case, we adjust the rest of the process to restore the actual amount of money we stole.
    // Money stolen by 1 thread (unaffected by cores)
    let hackPercent = await ns.formulas.hacking.hackPercent(ns.getServer(host.name), ns.getPlayer());
    let hackPowerNeeded = 0;
    if (hackPercent === 0)
    {
        hackPercent = 0.1;
    }
    if (hackPercent > hackTarget)
    {
        hackPowerNeeded = 1;
    }
    else
    {
        hackPowerNeeded = (hackTarget) / hackPercent;
    }
    hackPowerNeeded = Math.ceil(hackPowerNeeded);
    let moneyStolen = hackTarget;
    let currentMoneyRatio = await ns.getServerMoneyAvailable(host.name) / host.maxMoney;
    if (currentMoneyRatio === 0)
    {
        currentMoneyRatio = 0.001;
    }
    if (prep)
    {
        moneyStolen = (1 - currentMoneyRatio);
    }
    if (moneyStolen &lt; hackTarget)
    {
        moneyStolen = hackTarget;
    }
    // Now, compute the power needed to restore the target's money
    let moneyStolenRatio = moneyStolen / host.maxMoney;
    let growPowerNeeded = 0;
    let targetGrowth = 1 / (1 - hackTarget);
    growPowerNeeded = ns.growthAnalyze(host.name, targetGrowth) * 1.05;
    growPowerNeeded = Math.ceil(growPowerNeeded);

    // Now, compute the amount of security these two processes will add
    const securityAddedPerGrowth = 0.004;
    const securityAddedPerHack = 0.002;
    let securityAdded = growPowerNeeded * securityAddedPerGrowth + hackPowerNeeded * securityAddedPerHack;
    const securityRemovedByWeaken = 0.04;
    let weakenPowerNeeded = (securityAdded / securityRemovedByWeaken) * 1.1;
    weakenPowerNeeded = Math.ceil(weakenPowerNeeded);

    // Debug prints
    // await ns.tprint(`Batch for ${host.name} would require ${growPowerNeeded} growth, ${weakenPowerNeeded} weaken, and ${hackPowerNeeded} hack\n`);

    let weakenTime = await ns.formulas.hacking.weakenTime(ns.getServer(host.name), ns.getPlayer());
    let growTime = await ns.formulas.hacking.growTime(ns.getServer(host.name), ns.getPlayer());
    let hackTime = await ns.formulas.hacking.hackTime(ns.getServer(host.name), ns.getPlayer());
    // Need to delay tasks so that they are not executed in this exact order: hack, grow, weaken, within 50ms of each other
    // typically, weaken is the slowest and hack is the fastest
    let batch = new wm.Batch(ns, []);
    let delay = 0;
    // launch longest task first, with no delay
    batch.add(new wm.Task(ns, "slave_weaken.js", true, weakenPowerNeeded, host.name, 0));

    // launch second longest task, with a slight delay so that it ends right before the weaken task
    let diff = (weakenTime - 50) - growTime;
    delay = diff > 0 ? diff : 0;
    // ns.tprint(`Weaken delay: ${0}`);
    batch.add(new wm.Task(ns, "slave_grow.js", true, growPowerNeeded, host.name, delay));
    hackPowerNeeded = prep ? 0 : hackPowerNeeded;
    if (!prep)
    {
        // launch third longest task, with a slight delay so that it ends right before the grow task
        diff = (growTime - 50) - hackTime;
        delay = diff > 0 ? diff : 0;
        batch.add(new wm.Task(ns, "slave_hack.js", false, hackPowerNeeded, host.name, delay));
        // ns.tprint(`Hack delay: ${delay}`);
    }
    // ns.tprint(`Batch for ${host.name} would require ${growPowerNeeded} growth, ${weakenPowerNeeded} weaken, and ${hackPowerNeeded} hack\n`);
    return batch;
}

const grownumber = 35;
const hacknumber = 35;
const weakennumber = grownumber * 0.2 + hacknumber * 0.2;

export async function main(ns)
{
    await lib.init(ns);
    // Get the list of hosts in the network
    let all_hosts = [];
    await lib.recurse_scan(ns, "home", all_hosts, [lib.try_nuke]);
    ns.disableLog("getHackingLevel");
    ns.disableLog("scan");
    ns.disableLog("sleep");

    // At this point, hosts is a list of all the hosts in the network.
    // To get our definitive host list, we need to filter out the hosts:
    //  * where we do not have root access

    // Filter out the hosts that we do not have root access to and that have no RAM available
    let hosts = all_hosts.filter(function (host) { return host.hasAdminRights; });
    hosts = hosts.filter(function (host) { return host.maxRam > 0; });

    // Now we need our target list.
    // To get our definitive target list, we need to filter out the targets:
    //  * where we do not have enough hacking level to hack
    //  * that have no money to hack
    //  * that are on the target blacklist

    // Filter out the targets that are on the target blacklist
    let targets = all_hosts.filter(function (host) { return lib.own_servers.indexOf(host.name) === -1; });

    // Filter out the targets that we do not have enough hacking level to hack
    targets = targets.filter(function (host) { return host.canHack });

    // Filter out the targets that have no money to hack
    targets = targets.filter(function (host) { return host.moneyMax > 0; });


    // const whitelist = ["foodnstuff", "n00dles", "joesguns"]
    // targets = targets.filter(function (host) { return whitelist.indexOf(host.name) !== -1; });


    // Now we have our definitive target and host list.
    await ns.tprint(`${targets.length} hackable targets found:\n`);
    for (let target of targets)
    {
        await ns.tprint(`  ${target.name}\n`);
    }

    await ns.sleep(100);
    await ns.tprint("Starting manager...\n");
    await ns.sleep(100);
    let manager = await wm.createWorkloadManager(ns);
    ns.atExit(() =>
    {
        ns.tprint("Exiting...");
        t.printReport(ns);
        manager.printReport();
    });
    await ns.tprint("Updating network...\n");
    await ns.sleep(100);
    await manager.update_network();
    await ns.sleep(100);
    await ns.tprint("Updating network...done\n");
    if (ns.args.find(arg => arg === "--clean"))
    {
        for (let host of hosts)
        {
            await ns.killall(host.name);
        }
        return;
    }
    await ns.tprint(`Available resources:\n`);
    await ns.tprint(`${await manager.summary()}\n`);
    let tick = 0;

    // for (let target of targets)
    // {
    //     let prep_batch = await generate_batch(ns, target, true);
    //     let timer_start = Date.now();

    //     let totalPowerAllocated = await manager.assign(prep_batch);
    //     let timer_end = Date.now();
    //     let timer_diff = timer_end - timer_start;
    //     let weakenTime = await ns.formulas.hacking.weakenTime(ns.getServer(target.name), ns.getPlayer());
    //     let growTime = await ns.formulas.hacking.growTime(ns.getServer(target.name), ns.getPlayer());
    //     let hackTime = await ns.formulas.hacking.hackTime(ns.getServer(target.name), ns.getPlayer());
    //     let offset = Math.max(weakenTime, growTime);
    //     // wait until targets are full to start the batches
    //     target.busyUntil = Date.now() + offset + 150;
    //     if (totalPowerAllocated &lt; prep_batch.cost)
    //     {
    //         await ns.tprint(`${target.name} could not be launched because it did not have enough power\n`);
    //     }
    // }

    while (true)
    {
        let timer_start = Date.now();
        if (tick % 100 === 0)
        {
            await manager.assign(new wm.Task(ns, "purchase.js", 1, "20", "yes"));
            await manager.update_network();
        }
        let timer_start_target = Date.now();
        let skipped = 0;
        let batch_timer = 0;
        let assign_timer = 0;
        let loop_threshold = Date.now() + 2000;
        const ramCost = new wm.Task(ns, "/slaves/grow.js", grownumber).powerNeeded
            + new wm.Task(ns, "/slaves/weaken.js", weakennumber).powerNeeded
            + new wm.Task(ns, "/slaves/hack_if_full.js", hacknumber).powerNeeded
            + 1;
        let i = 0;
        for (let target of targets)
        {
            i++;
            if (ramCost * i > await manager.get_available_ram())
            {
                skipped++;
                continue;
            }
            if (Date.now() > loop_threshold)
            {
                await ns.tprint(`Loop threshold reached, skipping remaining targets\n`);
                break;
            }
            // For each target, need to:
            //  * weaken until we are at the minimum security level
            //  * grow until we are at the maximum security level
            //  * launch a delayed hack task
            if (Date.now() &lt; target.busyUntil)
            {
                skipped++;
                continue;
            }
            // let batch_timer_start = Date.now();
            // let batch = await generate_batch(ns, target);
            // let batch_timer_end = Date.now();
            // batch_timer += batch_timer_end - batch_timer_start;
            // if (await manager.get_available_ram() >= batch.cost)
            // {
            //     let assign_timer_start = Date.now();
            //     let totalPowerAllocated = await manager.assign(batch);
            //     let assign_timer_end = Date.now();
            //     assign_timer += assign_timer_end - assign_timer_start;
            //     target.busyUntil = Date.now() + 33;
            //     // return;
            // }
            // else
            // {
            //     await ns.tprint(`Could not assign enough power to ${target.name} (${await manager.get_available_ram()}/${batch.cost})\n`);
            // }

            let growtask = new wm.Task(ns, "/slaves/grow.js", grownumber, target.name);
            let weakentask = new wm.Task(ns, "/slaves/weaken.js", weakennumber, target.name);
            let hacktask = new wm.Task(ns, "/slaves/hack_if_full.js", hacknumber, target.name);
            let batch = new wm.Batch(ns, [growtask, weakentask, hacktask]);
            let pow = await manager.assign(batch);
            if (pow &lt; batch.powerNeeded)
            {
                await ns.tprint(`Could not assign enough power to ${target.name} (${pow}/${batch.powerNeeded})\n`);
            }
            target.busyUntil = Date.now() + ns.getWeakenTime(target.name) / 2;
            // await ns.tprint(`${target.name} is busy for ${target.busyUntil - Date.now()}ms\n`);
            await ns.sleep(1);
        }
        let timer_end_target = Date.now();
        // await ns.tprint(`\tTargets took ${timer_end_target - timer_start_target}ms to update (batch: ${batch_timer}ms, assign: ${assign_timer}ms), skipped ${skipped}\n`);

        if (tick % 1000 === 0)
        {
            await ns.toast(`${await manager.summary()} (${skipped} skipped)`, "info", 4000);
        }
        if (tick === 100)
        {
            // return;
        }
        await ns.sleep(1);
        tick++;
        let timer_end = Date.now();
        // await ns.tprint(`Tick ${tick} in ${timer_end - timer_start}ms (${skipped} skipped)\n`);
        // return;
    }
}
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.7</a> on Tue Aug 09 2022 20:11:00 GMT+0000 (Coordinated Universal Time) using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
